# Logstash Pipeline Configuration for EMR Blockchain System
# Centralized log processing, parsing, and enrichment
# HIPAA-compliant log handling with audit trail preservation

input {
  # Application logs from EMR backend
  beats {
    port => 5044
    type => "emr-application"
  }

  # Fabric network logs
  tcp {
    port => 5000
    type => "fabric-network"
    codec => json_lines
  }

  # IPFS cluster logs
  udp {
    port => 5001
    type => "ipfs-cluster"
    codec => json_lines
  }

  # System logs via syslog
  syslog {
    port => 5514
    type => "system-logs"
  }

  # Security logs
  tcp {
    port => 5002
    type => "security-logs"
    codec => json_lines
  }

  # Audit logs (HIPAA compliance)
  tcp {
    port => 5003
    type => "audit-logs"
    codec => json_lines
  }

  # Database logs
  tcp {
    port => 5004
    type => "database-logs"
    codec => json_lines
  }

  # Monitoring system logs
  tcp {
    port => 5005
    type => "monitoring-logs"
    codec => json_lines
  }
}

filter {
  # Add common fields to all logs
  mutate {
    add_field => {
      "[@metadata][environment]" => "production"
      "[@metadata][system]" => "emr-blockchain"
      "[@metadata][processed_at]" => "%{+YYYY-MM-dd HH:mm:ss}"
    }
  }

  # Parse EMR application logs
  if [type] == "emr-application" {
    # Parse JSON logs
    if [message] =~ /^\{.*\}$/ {
      json {
        source => "message"
      }
    }

    # Extract log level
    grok {
      match => { "message" => "%{TIMESTAMP_ISO8601:timestamp} \[%{LOGLEVEL:log_level}\] %{GREEDYDATA:log_message}" }
    }

    # Parse API request logs
    if [log_message] =~ /API Request/ {
      grok {
        match => { 
          "log_message" => "API Request: %{WORD:http_method} %{URIPATH:api_endpoint} - User: %{WORD:user_id} - IP: %{IP:client_ip} - Duration: %{NUMBER:response_time:float}ms - Status: %{NUMBER:http_status:int}"
        }
      }

      # Classify API endpoints
      if [api_endpoint] =~ /^\/api\/v1\/medical-records/ {
        mutate { add_field => { "api_category" => "medical_records" } }
      } else if [api_endpoint] =~ /^\/api\/v1\/auth/ {
        mutate { add_field => { "api_category" => "authentication" } }
      } else if [api_endpoint] =~ /^\/api\/v1\/users/ {
        mutate { add_field => { "api_category" => "user_management" } }
      }

      # Flag slow requests
      if [response_time] and [response_time] > 2000 {
        mutate { add_field => { "performance_flag" => "slow_request" } }
      }

      # Flag error responses
      if [http_status] and [http_status] >= 400 {
        mutate { add_field => { "error_flag" => "http_error" } }
      }
    }

    # Parse database query logs
    if [log_message] =~ /Database Query/ {
      grok {
        match => { 
          "log_message" => "Database Query: %{GREEDYDATA:query} - Duration: %{NUMBER:query_duration:float}ms - Rows: %{NUMBER:rows_affected:int}"
        }
      }

      # Flag slow queries
      if [query_duration] and [query_duration] > 1000 {
        mutate { add_field => { "performance_flag" => "slow_query" } }
      }
    }

    # Parse security events
    if [log_message] =~ /(Authentication|Authorization|Security)/ {
      mutate { add_field => { "security_event" => "true" } }
      
      if [log_message] =~ /Failed/ {
        mutate { add_field => { "security_flag" => "failed_auth" } }
      }
    }
  }

  # Parse Fabric network logs
  if [type] == "fabric-network" {
    # Extract peer/orderer information
    grok {
      match => { 
        "message" => "%{TIMESTAMP_ISO8601:timestamp} \[%{WORD:component}\] %{LOGLEVEL:log_level} %{GREEDYDATA:log_message}"
      }
    }

    # Parse transaction logs
    if [log_message] =~ /Transaction/ {
      grok {
        match => { 
          "log_message" => "Transaction %{WORD:tx_id} - Chaincode: %{WORD:chaincode} - Function: %{WORD:function} - Duration: %{NUMBER:tx_duration:float}ms"
        }
      }

      mutate { add_field => { "blockchain_event" => "transaction" } }
    }

    # Parse block creation logs
    if [log_message] =~ /Block/ {
      grok {
        match => { 
          "log_message" => "Block %{NUMBER:block_number:int} created with %{NUMBER:tx_count:int} transactions"
        }
      }

      mutate { add_field => { "blockchain_event" => "block_creation" } }
    }

    # Parse consensus logs
    if [log_message] =~ /Consensus/ {
      mutate { add_field => { "blockchain_event" => "consensus" } }
    }
  }

  # Parse IPFS cluster logs
  if [type] == "ipfs-cluster" {
    # Extract IPFS operations
    if [log_message] =~ /(Pin|Unpin|Add|Get)/ {
      grok {
        match => { 
          "log_message" => "%{WORD:ipfs_operation} %{WORD:cid} - Duration: %{NUMBER:ipfs_duration:float}ms - Size: %{NUMBER:file_size:int} bytes"
        }
      }

      mutate { add_field => { "storage_event" => "true" } }
    }

    # Parse replication events
    if [log_message] =~ /Replication/ {
      mutate { add_field => { "storage_event" => "replication" } }
    }
  }

  # Parse security logs
  if [type] == "security-logs" {
    mutate { add_field => { "security_event" => "true" } }

    # Parse authentication events
    if [log_message] =~ /Authentication/ {
      grok {
        match => { 
          "log_message" => "Authentication %{WORD:auth_result} - User: %{WORD:user_id} - IP: %{IP:client_ip} - Method: %{WORD:auth_method}"
        }
      }
    }

    # Parse authorization events
    if [log_message] =~ /Authorization/ {
      grok {
        match => { 
          "log_message" => "Authorization %{WORD:authz_result} - User: %{WORD:user_id} - Resource: %{GREEDYDATA:resource} - Action: %{WORD:action}"
        }
      }
    }

    # Flag security violations
    if [log_message] =~ /(Failed|Denied|Violation|Breach)/ {
      mutate { add_field => { "security_flag" => "violation" } }
    }
  }

  # Parse audit logs (HIPAA compliance)
  if [type] == "audit-logs" {
    mutate { add_field => { "audit_event" => "true" } }

    # Parse patient data access
    if [log_message] =~ /Patient Data Access/ {
      grok {
        match => { 
          "log_message" => "Patient Data Access - Patient: %{WORD:patient_id} - User: %{WORD:user_id} - Action: %{WORD:action} - Record: %{WORD:record_id}"
        }
      }

      mutate { add_field => { "hipaa_event" => "patient_data_access" } }
    }

    # Parse data modifications
    if [log_message] =~ /Data Modification/ {
      grok {
        match => { 
          "log_message" => "Data Modification - Record: %{WORD:record_id} - User: %{WORD:user_id} - Action: %{WORD:action} - Changes: %{GREEDYDATA:changes}"
        }
      }

      mutate { add_field => { "hipaa_event" => "data_modification" } }
    }

    # Parse data sharing events
    if [log_message] =~ /Data Sharing/ {
      grok {
        match => { 
          "log_message" => "Data Sharing - Record: %{WORD:record_id} - From: %{WORD:from_user} - To: %{WORD:to_user} - Purpose: %{GREEDYDATA:purpose}"
        }
      }

      mutate { add_field => { "hipaa_event" => "data_sharing" } }
    }
  }

  # Parse database logs
  if [type] == "database-logs" {
    # Parse slow query logs
    if [log_message] =~ /slow query/ {
      grok {
        match => { 
          "log_message" => "slow query: Query_time: %{NUMBER:query_time:float} Lock_time: %{NUMBER:lock_time:float} Rows_sent: %{NUMBER:rows_sent:int} Rows_examined: %{NUMBER:rows_examined:int} %{GREEDYDATA:query}"
        }
      }

      mutate { add_field => { "performance_flag" => "slow_db_query" } }
    }

    # Parse connection logs
    if [log_message] =~ /(Connect|Disconnect)/ {
      mutate { add_field => { "db_event" => "connection" } }
    }
  }

  # Enrich logs with GeoIP information
  if [client_ip] {
    geoip {
      source => "client_ip"
      target => "geoip"
    }
  }

  # Add timestamp parsing
  date {
    match => [ "timestamp", "ISO8601" ]
    target => "@timestamp"
  }

  # Remove sensitive information (HIPAA compliance)
  mutate {
    remove_field => [ "password", "ssn", "credit_card", "medical_record_number" ]
  }

  # Add severity levels
  if [log_level] == "ERROR" or [security_flag] == "violation" {
    mutate { add_field => { "severity" => "high" } }
  } else if [log_level] == "WARN" or [performance_flag] {
    mutate { add_field => { "severity" => "medium" } }
  } else {
    mutate { add_field => { "severity" => "low" } }
  }
}

output {
  # Send to Elasticsearch for indexing and search
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "emr-logs-%{+YYYY.MM.dd}"
    template_name => "emr-logs"
    template => "/usr/share/logstash/templates/emr-logs-template.json"
    template_overwrite => true
  }

  # Send security events to dedicated security index
  if [security_event] == "true" {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "emr-security-%{+YYYY.MM.dd}"
    }
  }

  # Send audit events to dedicated audit index (HIPAA compliance)
  if [audit_event] == "true" {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "emr-audit-%{+YYYY.MM.dd}"
    }
  }

  # Send performance events to dedicated performance index
  if [performance_flag] {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "emr-performance-%{+YYYY.MM.dd}"
    }
  }

  # Send blockchain events to dedicated blockchain index
  if [blockchain_event] {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "emr-blockchain-%{+YYYY.MM.dd}"
    }
  }

  # Send critical events to alerting system
  if [severity] == "high" {
    http {
      url => "http://webhook-receiver:9000/hooks/critical-log-alert"
      http_method => "post"
      format => "json"
      mapping => {
        "timestamp" => "%{@timestamp}"
        "message" => "%{log_message}"
        "severity" => "%{severity}"
        "source" => "%{type}"
        "host" => "%{host}"
      }
    }
  }

  # Debug output (remove in production)
  # stdout { codec => rubydebug }
}

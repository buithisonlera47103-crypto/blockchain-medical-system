# 数据库架构设计文档

## 1. 概述

本文档详细描述了区块链电子病历共享系统的数据库架构设计，包括数据模型、表结构、索引策略、分区方案以及性能优化措施。

### 1.1 设计原则

- **数据一致性**：确保医疗数据的完整性和准确性
- **高可用性**：支持7x24小时不间断服务
- **可扩展性**：支持水平和垂直扩展
- **安全性**：敏感数据加密存储，访问控制严格
- **性能优化**：合理的索引设计和查询优化

## 2. 数据库技术栈

### 2.1 主数据库

- **PostgreSQL 14+**：主要关系型数据库
- **连接池**：PgBouncer
- **备份策略**：pg_dump + WAL归档

### 2.2 缓存层

- **Redis 6+**：会话缓存、查询缓存
- **集群模式**：Redis Cluster

### 2.3 文件存储

- **IPFS**：分布式文件存储
- **MinIO**：对象存储服务

## 3. 核心数据模型

### 3.1 用户管理模块

```sql
-- 用户表
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    role user_role NOT NULL DEFAULT 'patient',
    profile JSONB,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 用户角色枚举
CREATE TYPE user_role AS ENUM (
    'patient',
    'doctor', 
    'nurse',
    'admin',
    'researcher'
);

-- 用户配置表
CREATE TABLE user_profiles (
    user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    phone VARCHAR(20),
    address JSONB,
    medical_license VARCHAR(100),
    specialization VARCHAR(100),
    institution_id UUID REFERENCES institutions(id)
);
```

### 3.2 医疗记录模块

```sql
-- 医疗记录主表
CREATE TABLE medical_records (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    patient_id UUID NOT NULL REFERENCES users(id),
    doctor_id UUID NOT NULL REFERENCES users(id),
    record_type record_type NOT NULL,
    title VARCHAR(255) NOT NULL,
    description TEXT,
    diagnosis JSONB,
    treatment JSONB,
    medications JSONB,
    attachments JSONB,
    blockchain_hash VARCHAR(64),
    ipfs_hash VARCHAR(64),
    status record_status DEFAULT 'draft',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 记录类型枚举
CREATE TYPE record_type AS ENUM (
    'consultation',
    'diagnosis',
    'treatment',
    'prescription',
    'lab_result',
    'imaging',
    'surgery'
);

-- 记录状态枚举
CREATE TYPE record_status AS ENUM (
    'draft',
    'pending',
    'approved',
    'archived'
);
```

### 3.3 权限管理模块

```sql
-- 访问权限表
CREATE TABLE access_permissions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    record_id UUID NOT NULL REFERENCES medical_records(id),
    granted_to UUID NOT NULL REFERENCES users(id),
    granted_by UUID NOT NULL REFERENCES users(id),
    permission_type permission_type NOT NULL,
    expires_at TIMESTAMP WITH TIME ZONE,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 权限类型枚举
CREATE TYPE permission_type AS ENUM (
    'read',
    'write',
    'share',
    'delete'
);

-- 审计日志表
CREATE TABLE audit_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id),
    action VARCHAR(50) NOT NULL,
    resource_type VARCHAR(50) NOT NULL,
    resource_id UUID,
    details JSONB,
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

## 4. 索引策略

### 4.1 主要索引

```sql
-- 用户表索引
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_role ON users(role);
CREATE INDEX idx_users_active ON users(is_active);

-- 医疗记录索引
CREATE INDEX idx_medical_records_patient ON medical_records(patient_id);
CREATE INDEX idx_medical_records_doctor ON medical_records(doctor_id);
CREATE INDEX idx_medical_records_type ON medical_records(record_type);
CREATE INDEX idx_medical_records_status ON medical_records(status);
CREATE INDEX idx_medical_records_created ON medical_records(created_at DESC);
CREATE INDEX idx_medical_records_blockchain ON medical_records(blockchain_hash);

-- 复合索引
CREATE INDEX idx_medical_records_patient_type ON medical_records(patient_id, record_type);
CREATE INDEX idx_medical_records_patient_created ON medical_records(patient_id, created_at DESC);

-- 权限表索引
CREATE INDEX idx_access_permissions_record ON access_permissions(record_id);
CREATE INDEX idx_access_permissions_user ON access_permissions(granted_to);
CREATE INDEX idx_access_permissions_active ON access_permissions(is_active);

-- 审计日志索引
CREATE INDEX idx_audit_logs_user ON audit_logs(user_id);
CREATE INDEX idx_audit_logs_action ON audit_logs(action);
CREATE INDEX idx_audit_logs_created ON audit_logs(created_at DESC);
```

### 4.2 全文搜索索引

```sql
-- 医疗记录全文搜索
CREATE INDEX idx_medical_records_fulltext ON medical_records 
USING gin(to_tsvector('english', title || ' ' || description));

-- 用户搜索索引
CREATE INDEX idx_users_fulltext ON users 
USING gin(to_tsvector('english', username || ' ' || email));
```

## 5. 分区策略

### 5.1 时间分区

```sql
-- 审计日志按月分区
CREATE TABLE audit_logs_y2024m01 PARTITION OF audit_logs
FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');

CREATE TABLE audit_logs_y2024m02 PARTITION OF audit_logs
FOR VALUES FROM ('2024-02-01') TO ('2024-03-01');

-- 自动分区管理
CREATE OR REPLACE FUNCTION create_monthly_partition(table_name text, start_date date)
RETURNS void AS $$
DECLARE
    partition_name text;
    end_date date;
BEGIN
    partition_name := table_name || '_y' || EXTRACT(year FROM start_date) || 'm' || LPAD(EXTRACT(month FROM start_date)::text, 2, '0');
    end_date := start_date + INTERVAL '1 month';
    
    EXECUTE format('CREATE TABLE %I PARTITION OF %I FOR VALUES FROM (%L) TO (%L)',
                   partition_name, table_name, start_date, end_date);
END;
$$ LANGUAGE plpgsql;
```

## 6. 数据安全

### 6.1 敏感数据加密

```sql
-- 启用pgcrypto扩展
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- 敏感字段加密函数
CREATE OR REPLACE FUNCTION encrypt_sensitive_data(data text)
RETURNS text AS $$
BEGIN
    RETURN encode(encrypt(data::bytea, 'encryption_key', 'aes'), 'base64');
END;
$$ LANGUAGE plpgsql;

-- 解密函数
CREATE OR REPLACE FUNCTION decrypt_sensitive_data(encrypted_data text)
RETURNS text AS $$
BEGIN
    RETURN convert_from(decrypt(decode(encrypted_data, 'base64'), 'encryption_key', 'aes'), 'UTF8');
END;
$$ LANGUAGE plpgsql;
```

### 6.2 行级安全策略

```sql
-- 启用行级安全
ALTER TABLE medical_records ENABLE ROW LEVEL SECURITY;

-- 患者只能访问自己的记录
CREATE POLICY patient_own_records ON medical_records
FOR ALL TO patient_role
USING (patient_id = current_user_id());

-- 医生可以访问有权限的记录
CREATE POLICY doctor_permitted_records ON medical_records
FOR ALL TO doctor_role
USING (doctor_id = current_user_id() OR 
       EXISTS (SELECT 1 FROM access_permissions 
               WHERE record_id = medical_records.id 
               AND granted_to = current_user_id() 
               AND is_active = true));
```

## 7. 性能优化

### 7.1 查询优化

```sql
-- 常用查询的物化视图
CREATE MATERIALIZED VIEW patient_record_summary AS
SELECT 
    patient_id,
    COUNT(*) as total_records,
    COUNT(CASE WHEN record_type = 'diagnosis' THEN 1 END) as diagnosis_count,
    COUNT(CASE WHEN record_type = 'prescription' THEN 1 END) as prescription_count,
    MAX(created_at) as last_record_date
FROM medical_records
WHERE status = 'approved'
GROUP BY patient_id;

-- 定期刷新物化视图
CREATE OR REPLACE FUNCTION refresh_patient_summary()
RETURNS void AS $$
BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY patient_record_summary;
END;
$$ LANGUAGE plpgsql;
```

### 7.2 连接池配置

```ini
# pgbouncer.ini
[databases]
medical_db = host=localhost port=5432 dbname=medical_records

[pgbouncer]
listen_port = 6432
listen_addr = *
auth_type = md5
auth_file = /etc/pgbouncer/userlist.txt
pool_mode = transaction
max_client_conn = 1000
default_pool_size = 25
max_db_connections = 100
```

## 8. 备份与恢复

### 8.1 备份策略

```bash
#!/bin/bash
# 全量备份脚本
BACKUP_DIR="/backup/postgresql"
DATE=$(date +%Y%m%d_%H%M%S)
DB_NAME="medical_records"

# 创建备份目录
mkdir -p $BACKUP_DIR/$DATE

# 全量备份
pg_dump -h localhost -U postgres -d $DB_NAME -F c -b -v -f $BACKUP_DIR/$DATE/medical_records_$DATE.backup

# WAL归档
cp /var/lib/postgresql/14/main/pg_wal/* $BACKUP_DIR/$DATE/wal/

# 压缩备份
tar -czf $BACKUP_DIR/medical_records_backup_$DATE.tar.gz $BACKUP_DIR/$DATE

# 清理旧备份（保留30天）
find $BACKUP_DIR -name "*.tar.gz" -mtime +30 -delete
```

### 8.2 恢复流程

```bash
#!/bin/bash
# 数据库恢复脚本
BACKUP_FILE="$1"
TARGET_DB="medical_records_restore"

# 创建恢复数据库
createdb -h localhost -U postgres $TARGET_DB

# 恢复数据
pg_restore -h localhost -U postgres -d $TARGET_DB -v $BACKUP_FILE

# 验证数据完整性
psql -h localhost -U postgres -d $TARGET_DB -c "SELECT COUNT(*) FROM medical_records;"
```

## 9. 监控指标

### 9.1 关键性能指标

- **连接数**：当前活跃连接数
- **查询性能**：平均查询响应时间
- **锁等待**：锁等待时间和频率
- **缓存命中率**：Buffer cache命中率
- **磁盘I/O**：读写IOPS和延迟

### 9.2 监控查询

```sql
-- 慢查询监控
SELECT 
    query,
    calls,
    total_time,
    mean_time,
    rows
FROM pg_stat_statements
ORDER BY mean_time DESC
LIMIT 10;

-- 锁等待监控
SELECT 
    blocked_locks.pid AS blocked_pid,
    blocked_activity.usename AS blocked_user,
    blocking_locks.pid AS blocking_pid,
    blocking_activity.usename AS blocking_user,
    blocked_activity.query AS blocked_statement
FROM pg_catalog.pg_locks blocked_locks
JOIN pg_catalog.pg_stat_activity blocked_activity ON blocked_activity.pid = blocked_locks.pid
JOIN pg_catalog.pg_locks blocking_locks ON blocking_locks.locktype = blocked_locks.locktype
JOIN pg_catalog.pg_stat_activity blocking_activity ON blocking_activity.pid = blocking_locks.pid
WHERE NOT blocked_locks.granted;
```

## 10. 扩展规划

### 10.1 水平扩展

- **读写分离**：主从复制架构
- **分片策略**：按患者ID或时间分片
- **负载均衡**：HAProxy + Keepalived

### 10.2 垂直扩展

- **硬件升级**：CPU、内存、存储
- **参数调优**：shared_buffers、work_mem等
- **索引优化**：定期重建和分析

本文档将根据系统发展需要持续更新和完善。